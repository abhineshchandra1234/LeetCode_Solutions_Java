// 712. Minimum ASCII Delete Sum for Two Strings

/**
Intuition
we will solve this problem using top-down approach ie using recursion and memoziation
Let dp(i, j) be the answer for inputs s1[i:] and s2[j:].
we will have two ptrs i and j to traverse through strings s1 and s2
if s1 ptr has reached end, means we need to remove all remaining chars of s2
so we will delete s2 curr char by moving ptr and adding its ascii to curr state, and move to next char of s2
same we will do if s2 ptr has reached end
if both chars of s1 and s2 are equal, there is no deletion required move to next chars
then there will be two options remaining, either to take s1 char and skip s2 or to take s2 char and skip s1
we will take min of above two options and assign to curr state
Approach

Complexity
Time complexity: O(m*n), dp states
Space complexity: O(m*n), dp space
*/

class Solution {

    int m, n;
    int[][] dp;

    public int minimumDeleteSum(String s1, String s2) {
        m = s1.length();
        n = s2.length();

        dp = new int[m + 1][n + 1];

        for (int i = 0; i <= m; i++) {
            for (int j = 0; j <= n; j++) {
                dp[i][j] = -1;
            }
        }

        return solve(s1, s2, 0, 0);
    }

    private int solve(String s1, String s2, int i, int j) {
        if (i >= m && j >= n)
            return 0;

        if (dp[i][j] != -1)
            return dp[i][j];

        if (i >= m)
            return dp[i][j] = s2.charAt(j) + solve(s1, s2, i, j + 1);

        if (j >= n)
            return dp[i][j] = s1.charAt(i) + solve(s1, s2, i + 1, j);

        if (s1.charAt(i) == s2.charAt(j))
            return dp[i][j] = solve(s1, s2, i + 1, j + 1);

        int takeS1 = s1.charAt(i) + solve(s1, s2, i + 1, j);
        int takeS2 = s2.charAt(j) + solve(s1, s2, i, j + 1);

        return dp[i][j] = Math.min(takeS1, takeS2);
    }
}