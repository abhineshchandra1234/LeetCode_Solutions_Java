// 865. Smallest Subtree with all the Deepest Nodes

/*
Intuition
we will solve this problem using post order traversal and dfs
At each node we will find max depth of its left and right child
if both the max depths are equal and greater than max depth encountered so far
then we have got the smallest subtree with all deepest nodes and we will store the curr node in the res
Then we will finally return the res
Approach

Complexity
Time complexity: O(n)
Space complexity: O(n)
*/

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    int maxDepth = -1;
    TreeNode res = null;

    public TreeNode subtreeWithAllDeepest(TreeNode root) {
        postOrder(root, 0);
        return res;
    }

    private int postOrder(TreeNode node, int depth) {
        if (node == null)
            return depth;

        int left = postOrder(node.left, depth + 1);
        int right = postOrder(node.right, depth + 1);

        if (left == right) {
            maxDepth = Math.max(maxDepth, left);
            if (maxDepth == left) {
                res = node;
            }
        }

        return Math.max(left, right);
    }
}